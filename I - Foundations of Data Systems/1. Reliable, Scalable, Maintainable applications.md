# 1. Reliable, Scalable, Maintainable applications

> Most applications are data intensive rather than compute-intensive. It is more in demand to be able to desing them than know some algorithms.

**Reliability** - is the feature of software such that it continues working properly even if things do not go expected way. Reliable systems are fault tolerant or resilient.

**Scalability** - ability to remain performant when data amount or data load grows.

**Maintainability** - ability of system to be productively maintained by other people not much familiar with it.

## Reliability

### Faults

**Hardware faults** (disk, memory, cpu, network, power, etc).
Those doesn't come together unless there's common cause. If one hard disc crashed - unlikely reserved one will crash at the same time.

**Software faults** (assumptions about env, which sometimes are not satisfied, third-party dependency).

Software faults are shared across all nodes when given the same bad input. 

**Human errors** - most of faults are because of humans (they are not reliable). 
To prevent them:
- we'd implement ui such that it is easy to do the right thing and it is hard (and discouraged) to do wrong one;
- set up monitoring and mesurement;
- unit, integration, manual testing;
- separate environment where errors doesn't become faults (for example stage for client testing to not test on prod);
- create ways to quickly recover from faults. For example, data audit, way to rollback changes. Other example: in case data computed incorrectly, anticipate tool to do full recomputation of data (which is less performant, but reliable).

####  Importance of reliability

Outages in software and programmatic bugs usually cost lost profit and lost reputation. However sometimes software may have reduced reliability in case of development for untapped market (RAD).


## Scalability

Scalability is ability of system to scale (cope with increased load).

### Describing Load

Load is described by _load parameters_. For instance, req/sec to server, cache hit rates, ratio of reads/writes to database, etc.

> Fan-out - number of requests to other services necessary to serve incoming request.

In case of Twitter, where avarage post tweet rate is 4.6k/sec and read 300k/sec tweets in timeline, the main load parameter is _how much followers are per user_. For instance, some people have over 40 million followers which need to be posted every time celebrity post tweet.

### Describing Performance

> Latency and response time are not the same. Latency is actually time of request waiting to be handled.

Median measure is more important than arithmetic average. For instance if we take into account response time, median 100ms would mean that 50% of all requests are completed within 100ms limit. Median is 50-th percentile. There can also be 90-th percentile, 95-th, 99.9-th percentiles.

SLO (service level objectives) describe expected performance of the service.
SLA (service level agreements) describe expected availability of the service.
SLO & SLA usually are described in percentiles.

Head of line blocking - when slow request is taken for processing, all subsequent requests (usually fast ones) are waiting for former to complete. Therefore it is important to measure client-side response times.

#### Percentiles in practice

> **Tail latency amplification** - effect such that when in order **to serve single request**, there're multiple **other backend calls needed**. Even though ran in parallel, source request will have to **wait for the slowest request**.

Algorithms to evaluate percentiles are described here: forward decay [25], t-digest [26], or HdrHistogram [27].

### Approaches to cope with load

Shared-nothing architecture - load is distributed between multiple machines.

Elastic systems - which can add resources in response to increased load. They are useful when load increase is not predictable, unlike manual scaling.

An architecture of system highly depends on application. There's no silver bullet which fits for all cases. Many factors are taken into account: volume of reads/writes, volume of data, response time reqs etc. For instance, application which has to handle 100k req/sec with req of 1kB will be designed differently than app which has to handle 3 req/min, but with request of 2GB, though data throughput is the same.

## Maintainability

In order for system to be maintainable, three principles must be followed:

- **operability** - make it easy for operations to support;
- **simplicity** - make it easy for devs to understand;
- **evolvability** - make it easy for devs to support in future.

### Operability - making life easy for operations (ops)

This is about automation setup (CI, CD).

For system to be operable:
- set up monitoring of what is happening in system;
- make system independent of machine it is running on (for instance s3 for storage);
- docs;
- self-recovery when applicable, tools to recover manually.

### Simplicity - tackling complexity

When system is complex is is usual thing for budgets and schedules to be overrun.
Reduction of complexity doesn't mean reduction of functionality. It means reduction of unintended, accidental complexity, which we can avoid.

Complexity can be removed by introduction of abstractions. Good abstraction hides implementation details behind neat facade.

When using abstraction, we of course use all low-level details, however we do not use it directly, because abstraction allows us to not think about it.

### Evolvability - making changes easy

It is agility of data systems.

TDD and refactoring principles is really useful when requirements change frequently.

Ease of modification depends on simplicity and abstractions. Simple and easy-to-understand systems are easier to modify than other.

## Summary

Every system has 2 types of requirements:
- Functional (what system should actually do);
- Non-Functional (security, reliablity, compliance, scalability, compatibility, maintainablity)

_Reliability_ means system works correctly in case of faults. Faults can be hardware, software and human. Fault-tolerant systems hide some faults from end-users.

_Scalability_ means having strategies to cope with increased load. In order to talk about scalability, two things should be described quantitatively: load and performance. Scalable system anticipates adding processing capacity to remain reliable under high loads.

_Maintainability_ means making life easier for devs and ops. For devs: good abstractions. For ops: visibility into system health, ways to manage it.

